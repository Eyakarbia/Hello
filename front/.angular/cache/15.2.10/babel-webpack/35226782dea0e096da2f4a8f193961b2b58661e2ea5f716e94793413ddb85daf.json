{"ast":null,"code":"import { PiecesFactory } from '../classes/PiecesFactory';\nimport { Subject } from 'rxjs/internal/Subject';\nimport * as i0 from \"@angular/core\";\nconst SPAWN_POSITION_X = 4;\nconst SPAWN_POSITION_Y = -4;\nexport class Tile {\n  constructor() {\n    this.solid = false;\n    this.color = null;\n  }\n}\nexport class GameManagerService {\n  constructor() {\n    this.settings = {\n      tileSize: null\n    };\n    this._gridSize = {\n      width: 0,\n      height: 0\n    };\n    this._locked = true;\n    this._lineCleared = new Subject();\n    this._gameOver = new Subject();\n    this._keepMovingDown = false;\n    this.lineCleared$ = this._lineCleared.asObservable();\n    this.gameOver$ = this._gameOver.asObservable();\n  }\n  resume() {\n    throw new Error('Method not implemented.');\n  }\n  get elementsInRow() {\n    return this._gridSize.width;\n  }\n  initialize(width, height, gameSpeed, tileSize) {\n    this._gridSize.width = width;\n    this._gridSize.height = height;\n    this._gameSpeed = gameSpeed;\n    this._piecesFactory = new PiecesFactory(this._gridSize);\n    if (tileSize) {\n      this.settings.tileSize = tileSize;\n    }\n    this._initializeEmptyBoard();\n    this._spawnNewPiece();\n    this._drawPiece();\n  }\n  start() {\n    clearInterval(this._gameInterval);\n    this._gameInterval = setInterval(() => {\n      this._update();\n    }, this._gameSpeed);\n    this._locked = false;\n  }\n  stop() {\n    this._locked = true;\n    clearInterval(this._gameInterval);\n  }\n  reset() {\n    const emptyTile = new Tile();\n    for (let pos = 0; pos < this.grid.length; pos++) {\n      if (this.grid[pos].color || this.grid[pos].solid) {\n        this.__changeCell(pos, emptyTile);\n      }\n    }\n    this._spawnNewPiece();\n    this._drawPiece();\n  }\n  moveLeft() {\n    if (this._locked) {\n      return;\n    }\n    this._clearPiece();\n    this._piece.store();\n    this._piece.moveLeft();\n    if (this._collidesLeft()) {\n      this._piece.revert();\n    }\n    this._drawPiece();\n  }\n  moveRight() {\n    if (this._locked) {\n      return;\n    }\n    this._clearPiece();\n    this._piece.store();\n    this._piece.moveRight();\n    if (this._collidesRight()) {\n      this._piece.revert();\n    }\n    this._drawPiece();\n  }\n  drop() {\n    if (this._locked) {\n      return;\n    }\n    this._keepMovingDown = true;\n    while (!this._collidesBottom() && this._keepMovingDown) {\n      this._update();\n    }\n  }\n  rotate() {\n    if (this._locked) {\n      return;\n    }\n    this._clearPiece();\n    this._piece.store();\n    this._piece.rotate();\n    while (this._collidesRight()) {\n      this._piece.moveLeft();\n      if (this._collidesLeft()) {\n        this._piece.revert();\n        break;\n      }\n    }\n    this._drawPiece();\n  }\n  moveDown() {\n    this._update();\n  }\n  _clearFullLines() {\n    for (let row = this._gridSize.height - 1; row >= 0; row--) {\n      let isFull = true;\n      for (let col = 0; col < this._gridSize.width; col++) {\n        const pos = row * this._gridSize.width + col;\n        if (this.grid[pos].solid === false) {\n          isFull = false;\n          break;\n        }\n      }\n      if (isFull) {\n        const emptyRow = Array.apply(null, Array(this._gridSize.width)).map(idx => new Tile());\n        const topPortion = this.grid.slice(0, row * this._gridSize.width);\n        this.grid.splice(0, ++row * this._gridSize.width, ...emptyRow.concat(topPortion));\n        this._lineCleared.next();\n      }\n    }\n  }\n  _update() {\n    if (this._locked) {\n      return;\n    }\n    this._locked = true;\n    this._piece.revert();\n    this._clearPiece();\n    this._piece.store();\n    this._piece.moveDown();\n    if (this._collidesBottom()) {\n      this._keepMovingDown = false;\n      this._piece.revert();\n      this._markSolid();\n      this._drawPiece();\n      this._clearFullLines();\n      this._spawnNewPiece();\n      if (this._isGameOver()) {\n        this._onGameOver();\n        return;\n      }\n    }\n    this._drawPiece();\n    this._locked = false;\n  }\n  _isGameOver() {\n    this._piece.store();\n    this._piece.moveDown();\n    if (this._collidesBottom()) {\n      return true;\n    }\n    this._piece.revert();\n    return false;\n  }\n  _onGameOver() {\n    this.stop();\n    this._gameOver.next();\n  }\n  _spawnNewPiece() {\n    this._piece = this._piecesFactory.getRandomPiecePiece(SPAWN_POSITION_X, SPAWN_POSITION_Y);\n  }\n  _initializeEmptyBoard() {\n    const cellsCount = this._gridSize.width * this._gridSize.height;\n    this.grid = Array.apply(null, Array(cellsCount)).map(idx => new Tile());\n  }\n  _clearPiece() {\n    this._piece.positionsOnGrid.forEach(pos => {\n      this.__changeCell(pos, {\n        color: undefined\n      });\n    });\n  }\n  _drawPiece() {\n    this._piece.clearStore();\n    this._piece.positionsOnGrid.forEach(pos => {\n      this.__changeCell(pos, {\n        color: this._piece.color\n      });\n    });\n  }\n  _markSolid() {\n    this._piece.positionsOnGrid.forEach(pos => {\n      this.__changeCell(pos, {\n        solid: true\n      });\n    });\n  }\n  __changeCell(pos, data = {}) {\n    this.grid[pos] = Object.assign({}, this.grid[pos], data);\n  }\n  _collidesBottom() {\n    if (this._piece.bottomRow >= this._gridSize.height) {\n      return true;\n    }\n    return this.__collides();\n  }\n  _collidesLeft() {\n    if (this._piece.leftCol < 0) {\n      return true;\n    }\n    return this.__collides();\n  }\n  _collidesRight() {\n    if (this._piece.rightCol >= this._gridSize.width) {\n      return true;\n    }\n    return this.__collides();\n  }\n  __collides() {\n    return this._piece.positionsOnGrid.some(pos => {\n      if (pos > 0 && this.grid[pos] && this.grid[pos].solid) {\n        return true;\n      }\n      return false;\n    });\n  }\n  static #_ = this.ɵfac = function GameManagerService_Factory(t) {\n    return new (t || GameManagerService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GameManagerService,\n    factory: GameManagerService.ɵfac\n  });\n}","map":{"version":3,"mappings":"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","names":["PiecesFactory","Subject","SPAWN_POSITION_X","SPAWN_POSITION_Y","Tile","constructor","GameManagerService","tileSize","width","height","lineCleared$","_lineCleared","asObservable","gameOver$","_gameOver","resume","Error","elementsInRow","_gridSize","initialize","gameSpeed","_gameSpeed","_piecesFactory","settings","_initializeEmptyBoard","_spawnNewPiece","_drawPiece","start","clearInterval","_gameInterval","setInterval","_update","_locked","stop","reset","emptyTile","pos","grid","length","color","solid","__changeCell","moveLeft","_clearPiece","_piece","store","_collidesLeft","revert","moveRight","_collidesRight","drop","_keepMovingDown","_collidesBottom","rotate","moveDown","_clearFullLines","row","isFull","col","emptyRow","Array","apply","map","idx","topPortion","slice","splice","concat","next","_markSolid","_isGameOver","_onGameOver","getRandomPiecePiece","cellsCount","positionsOnGrid","forEach","undefined","clearStore","data","Object","assign","bottomRow","__collides","leftCol","rightCol","some","factory"],"sourceRoot":"","sources":["C:\\Users\\Tasnim\\OneDrive\\Desktop\\Tetris\\Hello\\front\\ngx-tetris\\src\\lib\\services\\game-manager.service.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\r\nimport {Piece} from '../classes/Piece';\r\nimport {PiecesFactory} from '../classes/PiecesFactory';\r\nimport {Observable} from 'rxjs/internal/Observable';\r\nimport {Subject} from 'rxjs/internal/Subject';\r\n\r\nconst SPAWN_POSITION_X = 4;\r\nconst SPAWN_POSITION_Y = -4;\r\n\r\nexport class Tile {\r\n    solid = false;\r\n    color = null;\r\n}\r\n\r\n@Injectable()\r\nexport class GameManagerService {\r\n    resume() {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    public settings = {\r\n        tileSize: null\r\n    };\r\n\r\n    public get elementsInRow() {\r\n        return this._gridSize.width;\r\n    }\r\n\r\n    // serialized grid :)\r\n    public grid!: Array<Tile>;\r\n\r\n    public lineCleared$: Observable<any>;\r\n    public gameOver$: Observable<any>;\r\n\r\n    private _gridSize: {\r\n        width: number,\r\n        height: number\r\n    } = { width: 0, height: 0 };\r\n\r\n    private _piece!: Piece;\r\n    private _piecesFactory!: PiecesFactory;\r\n\r\n    private _locked = true;\r\n    private _gameSpeed!: number;\r\n    private _gameInterval: NodeJS.Timeout | undefined;\r\n\r\n    private _lineCleared = new Subject<void>();\r\n    private _gameOver = new Subject<void>();\r\n\r\n    private _keepMovingDown = false;\r\n\r\n    constructor() {\r\n        this.lineCleared$ = this._lineCleared.asObservable();\r\n        this.gameOver$ = this._gameOver.asObservable();\r\n    }\r\n\r\n    public initialize(width: number, height: number, gameSpeed: number, tileSize?: any) {\r\n        this._gridSize.width = width;\r\n        this._gridSize.height = height;\r\n        this._gameSpeed = gameSpeed;\r\n        this._piecesFactory = new PiecesFactory(this._gridSize);\r\n\r\n        if (tileSize) {\r\n            this.settings.tileSize = tileSize;\r\n        }\r\n\r\n        this._initializeEmptyBoard();\r\n\r\n        this._spawnNewPiece();\r\n        this._drawPiece();\r\n    }\r\n\r\n    public start() {\r\n        clearInterval(this._gameInterval);\r\n        this._gameInterval = setInterval(() => {\r\n            this._update();\r\n        }, this._gameSpeed);\r\n        this._locked = false;\r\n    }\r\n\r\n    public stop() {\r\n        this._locked = true;\r\n        clearInterval(this._gameInterval);\r\n    }\r\n\r\n    public reset() {\r\n        const emptyTile = new Tile();\r\n        for (let pos = 0; pos < this.grid.length; pos++) {\r\n            if (this.grid[pos].color || this.grid[pos].solid) {\r\n                this.__changeCell(pos, emptyTile);\r\n            }\r\n        }\r\n\r\n        this._spawnNewPiece();\r\n        this._drawPiece();\r\n    }\r\n\r\n    public moveLeft() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.moveLeft();\r\n        if (this._collidesLeft()) {\r\n            this._piece.revert();\r\n        }\r\n\r\n        this._drawPiece();\r\n    }\r\n\r\n    public moveRight() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.moveRight();\r\n        if (this._collidesRight()) {\r\n            this._piece.revert();\r\n        }\r\n\r\n        this._drawPiece();\r\n    }\r\n\r\n    public drop() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._keepMovingDown = true;\r\n        while (!this._collidesBottom() && this._keepMovingDown) {\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    public rotate() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.rotate();\r\n        while (this._collidesRight()) {\r\n            this._piece.moveLeft();\r\n\r\n            if (this._collidesLeft()) {\r\n                this._piece.revert();\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._drawPiece();\r\n    }\r\n\r\n    public moveDown() {\r\n        this._update();\r\n    }\r\n\r\n    private _clearFullLines() {\r\n        for (let row = this._gridSize.height - 1; row >= 0; row--) {\r\n            let isFull = true;\r\n            for (let col = 0; col < this._gridSize.width; col++) {\r\n                const pos = row * this._gridSize.width + col;\r\n                if (this.grid[pos].solid === false) {\r\n                    isFull = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (isFull) {\r\n                const emptyRow = Array.apply(null, Array(this._gridSize.width))\r\n                    .map((idx) => new Tile());\r\n\r\n                const topPortion = this.grid.slice(0, row * this._gridSize.width);\r\n\r\n                this.grid.splice(0, ++row * this._gridSize.width, ...emptyRow.concat(topPortion));\r\n                this._lineCleared.next();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _update() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._locked = true;\r\n        this._piece.revert();\r\n\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.moveDown();\r\n        if (this._collidesBottom()) {\r\n            this._keepMovingDown = false;\r\n            this._piece.revert();\r\n            this._markSolid();\r\n            this._drawPiece();\r\n\r\n            this._clearFullLines();\r\n\r\n            this._spawnNewPiece();\r\n            if (this._isGameOver()) {\r\n                this._onGameOver();\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._drawPiece();\r\n        this._locked = false;\r\n    }\r\n\r\n    private _isGameOver() {\r\n        this._piece.store();\r\n        this._piece.moveDown();\r\n        if (this._collidesBottom()) {\r\n            return true;\r\n        }\r\n\r\n        this._piece.revert();\r\n        return false;\r\n    }\r\n\r\n    private _onGameOver() {\r\n        this.stop();\r\n        this._gameOver.next();\r\n    }\r\n\r\n    private _spawnNewPiece() {\r\n        this._piece = this._piecesFactory.getRandomPiecePiece(SPAWN_POSITION_X, SPAWN_POSITION_Y);\r\n    }\r\n\r\n    private _initializeEmptyBoard() {\r\n        const cellsCount = this._gridSize.width * this._gridSize.height;\r\n        this.grid = Array.apply(null, Array(cellsCount))\r\n            .map((idx) => new Tile());\r\n    }\r\n\r\n    private _clearPiece() {\r\n        this._piece.positionsOnGrid\r\n            .forEach((pos) => {\r\n                this.__changeCell(pos, {color: undefined});\r\n            });\r\n    }\r\n\r\n    private _drawPiece() {\r\n        this._piece.clearStore();\r\n        this._piece.positionsOnGrid\r\n            .forEach((pos) => {\r\n                this.__changeCell(pos, {color: this._piece.color});\r\n            });\r\n    }\r\n\r\n    private _markSolid() {\r\n        this._piece.positionsOnGrid.forEach((pos) => {\r\n            this.__changeCell(pos, {solid: true});\r\n        });\r\n    }\r\n\r\n    private __changeCell(pos: number, data = {}) {\r\n        this.grid[pos] = Object.assign({}, this.grid[pos], data);\r\n    }\r\n\r\n    private _collidesBottom() {\r\n        if (this._piece.bottomRow >= this._gridSize.height) {\r\n            return true;\r\n        }\r\n        return this.__collides();\r\n    }\r\n\r\n    private _collidesLeft() {\r\n        if (this._piece.leftCol < 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.__collides();\r\n    }\r\n\r\n    private _collidesRight() {\r\n        if (this._piece.rightCol >= this._gridSize.width) {\r\n            return true;\r\n        }\r\n\r\n        return this.__collides();\r\n    }\r\n\r\n    private __collides() {\r\n        return this._piece.positionsOnGrid\r\n            .some((pos) => {\r\n                if (pos > 0 && this.grid[pos] && this.grid[pos].solid) {\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n    }\r\n    \r\n\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}